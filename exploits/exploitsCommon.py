import os, sys
import subprocess
import collections


InstructionSequence = collections.namedtuple('InstructionSequence',
                                             'vmAddress vmAddressNumNullBytes assemblyString')


class Utils:
    @staticmethod
    def changeCWDToScriptDirectory():
        abspath = os.path.abspath(__file__)
        dname = os.path.dirname(abspath)
        os.chdir(dname)

    @staticmethod
    def runSubprocess(args):
        return subprocess.check_output(args, stderr=subprocess.STDOUT, text=True)

    @staticmethod
    def stringIsHexNumber(string):
        try:
            _ = int(string, 16)
            return True
        except:
            return False

    @staticmethod
    def getNumNullBytesInInteger(integer):
        intBytes = integer.to_bytes(8, 'little')

        numNullBytes = 0
        for b in intBytes:
            if b == 0x00:
                numNullBytes = numNullBytes + 1

        return numNullBytes


def getInstructionSequenceOutput(vulnerableProcessName):
    ropSearchPath = '../bin/ROPSearch.exe'
    vulnerableProcessPid = Utils.runSubprocess(['pidof', vulnerableProcessName]).strip()

    args = [
        ropSearchPath,
        'list',
        '-pid',
        vulnerableProcessPid,
    ]
    output = Utils.runSubprocess(args)

    lines = output.split(sep='\n')
    if len(lines) == 0:
        print(f'Found empty output when looking for instruction sequences in "{vulnerableProcessName}"')
        sys.exit(-1)

    instrSequences = []
    for line in lines:
        parts = line.split(': ', maxsplit=1)
        if len(parts) == 2 and Utils.stringIsHexNumber(parts[0]):
            virtualMemoryAddressHexString = parts[0]
            assemblyString = parts[1]

            virtualMemoryAddress = int(virtualMemoryAddressHexString, 16)
            virtualMemoryAddressNumBytes = Utils.getNumNullBytesInInteger(virtualMemoryAddress)

            iSeq = InstructionSequence(virtualMemoryAddress,
                                       virtualMemoryAddressNumBytes,
                                       assemblyString)
            instrSequences.append(iSeq)

    return instrSequences

def findInstructionSequenceAddress(instrSequences, targetInstrSeqString):
    usefulInstrSequences = [iSeq for iSeq in instrSequences if iSeq.assemblyString == targetInstrSeqString]
    if len(usefulInstrSequences) == 0:
        print(f'The output doesn\'t have the target instruction sequence: {targetInstrSeqString}')
        sys.exit(-1)

    # Sort the list such that the addresses with the least amount of NULL bytes are first.
    usefulInstrSequences.sort(key=(lambda instrSeq: instrSeq.vmAddressNumNullBytes))

    hexAddress = hex(usefulInstrSequences[0].vmAddress)
    print(f'{hexAddress}: "{targetInstrSeqString}"')

    return usefulInstrSequences[0].vmAddress

def getBytesOf32bitInstrSeqAddress(instrSequences, targetInstrSeqString):
    virtualAddress = findInstructionSequenceAddress(instrSequences, targetInstrSeqString)
    virtualAddressBytes = virtualAddress.to_bytes(4, 'little')
    return virtualAddressBytes

def getBytesOf64bitInstrSeqAddress(instrSequences, targetInstrSeqString):
    virtualAddress = findInstructionSequenceAddress(instrSequences, targetInstrSeqString)
    virtualAddressBytes = virtualAddress.to_bytes(8, 'little')
    return virtualAddressBytes

def convertStringToCStringBytes(string):
    return bytes(string, 'utf-8') + b'\x00'
