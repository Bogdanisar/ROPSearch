import os, sys
import subprocess
import collections


class Utils:
    @staticmethod
    def changeCWDToScriptDirectory():
        abspath = os.path.abspath(__file__)
        dname = os.path.dirname(abspath)
        os.chdir(dname)

    @staticmethod
    def runSubprocess(args):
        return subprocess.check_output(args, stderr=subprocess.STDOUT, text=True)

    @staticmethod
    def stringIsHexNumber(string):
        try:
            _ = int(string, 16)
            return True
        except:
            return False

    @staticmethod
    def getNumNullBytesInInteger(integer):
        intBytes = integer.to_bytes(8, 'little')

        numNullBytes = 0
        for b in intBytes:
            if b == 0x00:
                numNullBytes = numNullBytes + 1

        return numNullBytes


InstructionSequence = collections.namedtuple('InstructionSequence',
                                             'vmAddress vmAddressNumNullBytes assemblyString')

class ExploitBuilder:

    def __init__(self, targetProcessName, archBitSize):
        self.targetProcessName = targetProcessName

        assert archBitSize == 32 or archBitSize == 64
        self.archBitSize = archBitSize
        self.archByteSize = archBitSize // 8

        # Run the tool on the target process and gather all the resulting instruction sequences.
        self.outputInstrSequences = self.getInstructionSequenceOutput(self.targetProcessName)

    def getInstructionSequenceOutput(self, targetProcessName):
        ropSearchPath = '../bin/ROPSearch.exe'
        vulnerableProcessPid = Utils.runSubprocess(['pidof', targetProcessName]).strip()

        args = [
            ropSearchPath,
            'list',
            '-pid',
            vulnerableProcessPid,
        ]
        output = Utils.runSubprocess(args)

        lines = output.split(sep='\n')
        if len(lines) == 0:
            print(f'Found empty output when looking for instruction sequences in "{targetProcessName}"')
            sys.exit(-1)

        instrSequences = []
        for line in lines:
            parts = line.split(': ', maxsplit=1)
            if len(parts) == 2 and Utils.stringIsHexNumber(parts[0]):
                virtualMemoryAddressHexString = parts[0]
                assemblyString = parts[1]

                virtualMemoryAddress = int(virtualMemoryAddressHexString, 16)
                virtualMemoryAddressNumBytes = Utils.getNumNullBytesInInteger(virtualMemoryAddress)

                iSeq = InstructionSequence(virtualMemoryAddress,
                                           virtualMemoryAddressNumBytes,
                                           assemblyString)
                instrSequences.append(iSeq)

        return instrSequences

    def findInstructionSequenceAddress(self, targetInstrSeqString):
        usefulInstrSequences = [iSeq for iSeq in self.outputInstrSequences if iSeq.assemblyString == targetInstrSeqString]
        if len(usefulInstrSequences) == 0:
            print(f'The output doesn\'t have the target instruction sequence: {targetInstrSeqString}')
            sys.exit(-1)

        # Sort the list such that the addresses with the least amount of NULL bytes are first.
        usefulInstrSequences.sort(key=(lambda instrSeq: instrSeq.vmAddressNumNullBytes))

        hexAddress = hex(usefulInstrSequences[0].vmAddress)
        print(f'{hexAddress}: "{targetInstrSeqString}"')

        return usefulInstrSequences[0].vmAddress

    def getBytesOfInstrSeqAddress(self, targetInstrSeqString, endianness='little'):
        virtualAddress = self.findInstructionSequenceAddress(targetInstrSeqString)
        virtualAddressBytes = virtualAddress.to_bytes(self.archByteSize, endianness)
        return virtualAddressBytes

    @staticmethod
    def convertStringToCStringBytes(string):
        return bytes(string, 'utf-8') + b'\x00'
