#include "InstructionConverter.hpp"

#include <capstone/capstone.h>
#include <keystone/keystone.h>


void ROP::InstructionConverter::initKeystone() {
    ks_err err;

    err = ks_open(KS_ARCH_X86, KS_MODE_64, &this->ksEngine);
    if (err != KS_ERR_OK) {
        exiterror("Keystone: ks_open() failed with error %u!\n", (unsigned)err);
    }

    // Adjust the engine to use Intel syntax by default.
    err = ks_option(this->ksEngine, KS_OPT_SYNTAX, KS_OPT_SYNTAX_INTEL);
    if (err != KS_ERR_OK) {
        exiterror("Keystone: ks_option() failed with error %u!\n", (unsigned)err);
    }

    this->ksEngineSyntax = AssemblySyntax::Intel;
}

void ROP::InstructionConverter::initCapstone() {
    cs_err err;

	err = cs_open(CS_ARCH_X86, CS_MODE_64, &this->capstoneHandle);
    if (err != CS_ERR_OK) {
        exiterror("Capstone: cs_open() failed with error %u!\n", (unsigned)err);
    }

    // Adjust the engine to use Intel syntax by default.
    err = cs_option(this->capstoneHandle, CS_OPT_SYNTAX, CS_OPT_SYNTAX_INTEL);
    if (err != CS_ERR_OK) {
        exiterror("Capstone: cs_option() failed with error %u!\n", (unsigned)err);
    }

    this->csHandleSyntax = AssemblySyntax::Intel;
}

ROP::InstructionConverter::InstructionConverter() {
    this->initKeystone();
    this->initCapstone();
}

std::pair<ROP::byteSequence, unsigned>
ROP::InstructionConverter::convertInstructionSequenceToBytes(
    std::string instructionSequenceAsm,
    AssemblySyntax asmSyntax,
    unsigned long long addr
) {
    byteSequence instructionSequence;

    ks_err err;
    ks_opt_value newSyntaxValue;
    const char * const insSeqCString = instructionSequenceAsm.c_str();
    unsigned char *insSeqEncoding = NULL;
    size_t insSeqEncodingSize;
    size_t numDecodedInstructions;

    // Adjust the engine (if needed) to use Intel or AT&T syntax.
    if (this->ksEngineSyntax != asmSyntax) {
        newSyntaxValue = (asmSyntax == AssemblySyntax::Intel) ? KS_OPT_SYNTAX_INTEL : KS_OPT_SYNTAX_ATT;
        err = ks_option(this->ksEngine, KS_OPT_SYNTAX, newSyntaxValue);
        if (err != KS_ERR_OK) {
            printf("Keystone: ks_option() failed with error %u!\n", (unsigned)err);
            goto cleanup;
        }

        this->ksEngineSyntax = asmSyntax;
    }

    if (ks_asm(this->ksEngine, insSeqCString, addr, &insSeqEncoding, &insSeqEncodingSize, &numDecodedInstructions) != 0) {
        printf("Keystone: ks_asm() failed with error %u; Number of decoded instructions = %u;\n",
               (unsigned)ks_errno(this->ksEngine), (unsigned)numDecodedInstructions);
        goto cleanup;
    }

    for (size_t i = 0; i < insSeqEncodingSize; ++i) {
        instructionSequence.push_back((byte)insSeqEncoding[i]);
    }

cleanup:
    // Free the bytes generated by Keystone.
    if (insSeqEncoding != NULL) {
        ks_free(insSeqEncoding);
    }

// Final
    if (instructionSequence.size() == 0) {
        pv(instructionSequenceAsm); pn;
        pv(numDecodedInstructions); pn;
        exiterror("Keystone conversion from instruction sequence string to instruction sequence bytes failed");
    }

    return {instructionSequence, numDecodedInstructions};
}

std::pair<std::vector<std::string>, unsigned>
ROP::InstructionConverter::convertInstructionSequenceToString(
    const byte * const instrSeqBytes,
    const size_t instrSeqBytesCount,
    AssemblySyntax asmSyntax,
    unsigned long long addr,
    const size_t parseCount
) {
    cs_err err;
    size_t newSyntaxValue;
	cs_insn *decodedInstructions = NULL;
	size_t decodedInstructionsCount;
    size_t idx;
    std::vector<std::string> decodedInstructionsAsm;
    unsigned totalDecodedBytes = 0;

    // Adjust the handle (if needed) to use Intel or AT&T syntax.
    if (this->csHandleSyntax != asmSyntax) {
        newSyntaxValue = (asmSyntax == AssemblySyntax::Intel) ? CS_OPT_SYNTAX_INTEL : CS_OPT_SYNTAX_ATT;
        err = cs_option(this->capstoneHandle, CS_OPT_SYNTAX, newSyntaxValue);
        if (err != CS_ERR_OK) {
            printf("Capstone: cs_option() failed with error %u!\n", (unsigned)err);
            goto cleanup;
        }

        this->csHandleSyntax = asmSyntax;
    }

	decodedInstructionsCount = cs_disasm(this->capstoneHandle,
                                         (const uint8_t *)instrSeqBytes,
                                         instrSeqBytesCount,
                                         addr, // Address of first instruction
                                         parseCount,
                                         &decodedInstructions);
    err = cs_errno(this->capstoneHandle);
    if (decodedInstructionsCount == 0 && err != CS_ERR_OK) {
        printf("Capstone: cs_disasm() failed with error %u\n", (unsigned)err);
        goto cleanup;
    }

    for (idx = 0; idx < decodedInstructionsCount; ++idx) {
        std::string mnemonic = std::string(decodedInstructions[idx].mnemonic);
        std::string operands = std::string(decodedInstructions[idx].op_str);

        std::string instructionAsm = mnemonic;
        if (operands.size() != 0) {
            instructionAsm += " " + operands;
        }

        decodedInstructionsAsm.push_back(instructionAsm);
        totalDecodedBytes += decodedInstructions[idx].size;
    }

cleanup:
    if (decodedInstructions != NULL) {
        cs_free(decodedInstructions, decodedInstructionsCount);
    }

// Final
    return { decodedInstructionsAsm, totalDecodedBytes };
}

std::pair<std::vector<std::string>, unsigned>
ROP::InstructionConverter::convertInstructionSequenceToString(
    byteSequence instructionSequence,
    AssemblySyntax asmSyntax,
    unsigned long long addr,
    const size_t parseCount
) {
    const byte *instrSeqBytes = (const byte *)instructionSequence.data();
    const size_t instrSeqBytesCount = instructionSequence.size();
    return this->convertInstructionSequenceToString(instrSeqBytes, instrSeqBytesCount, asmSyntax, addr, parseCount);
}

std::vector<std::string>
ROP::InstructionConverter::normalizeInstructionAsm(std::string origInsSequenceAsm, ROP::AssemblySyntax inputAsmSyntax) {
    const byteSequence& insSeqBytes = this->convertInstructionSequenceToBytes(origInsSequenceAsm, inputAsmSyntax).first;

    AssemblySyntax internalSyntax = ROPConsts::InstructionASMSyntax;
    auto p = this->convertInstructionSequenceToString(insSeqBytes, internalSyntax);

    std::vector<std::string> instructions = p.first;
    assert(p.second == insSeqBytes.size());

    return instructions;
}

std::string
ROP::InstructionConverter::concatenateInstructionsAsm(std::vector<std::string> instructionsAsm) {
    std::string ret = "";

    for (size_t i = 0; i < instructionsAsm.size(); ++i) {
        ret = (ret + instructionsAsm[i]);
        if (i != instructionsAsm.size() - 1) {
            ret += "; ";
        }
    }

    return ret;
}

ROP::InstructionConverter::~InstructionConverter() {
    // Close the Keystone instance.
    ks_close(this->ksEngine);

    // Close the Capstone instance.
    cs_close(&this->capstoneHandle);
}
