#include "InstructionConverter.hpp"

#include <capstone/capstone.h>
#include <keystone/keystone.h>


std::pair<ROOP::byteSequence, unsigned>
ROOP::InstructionConverter::convertInstructionSequenceToBytes(std::string instructionSequenceAsm, AssemblySyntax asmSyntax) {
    byteSequence instructionSequence;

    ks_err err;
    ks_engine *ksEngine = NULL;
    const char * const insSeqCString = instructionSequenceAsm.c_str();
    unsigned char *insSeqEncoding = NULL;
    size_t insSeqEncodingSize;
    size_t numDecodedInstructions;
    ks_opt_value syntaxValue;

    err = ks_open(KS_ARCH_X86, KS_MODE_64, &ksEngine);
    if (err != KS_ERR_OK) {
        printf("Keystone: ks_open() failed with error %u!\n", (unsigned)err);
        goto cleanup;
    }

    // Adjust the engine to use Intel or AT&T syntax.
    syntaxValue = (asmSyntax == AssemblySyntax::Intel) ? KS_OPT_SYNTAX_INTEL : KS_OPT_SYNTAX_ATT;
    err = ks_option(ksEngine, KS_OPT_SYNTAX, syntaxValue);
    if (err != KS_ERR_OK) {
        printf("Keystone: ks_option() failed with error %u!\n", (unsigned)err);
        goto cleanup;
    }

    if (ks_asm(ksEngine, insSeqCString, 0, &insSeqEncoding, &insSeqEncodingSize, &numDecodedInstructions) != 0) {
        printf("Keystone: ks_asm() failed with error %u; Number of decoded instructions = %u;\n",
               (unsigned)ks_errno(ksEngine), (unsigned)numDecodedInstructions);
        goto cleanup;
    }

    for (size_t i = 0; i < insSeqEncodingSize; ++i) {
        instructionSequence.push_back((byte)insSeqEncoding[i]);
    }

cleanup:
    // Free the bytes generated by Keystone.
    if (insSeqEncoding != NULL) {
        ks_free(insSeqEncoding);
    }

    // Close the Keystone instance.
    if (ksEngine != NULL) {
        ks_close(ksEngine);
    }

// Final
    if (instructionSequence.size() == 0) {
        pv(instructionSequenceAsm); pn;
        pv(numDecodedInstructions); pn;
        exiterror("Keystone conversion from instruction sequence string to instruction sequence bytes failed");
    }

    return {instructionSequence, numDecodedInstructions};
}

std::pair<std::vector<std::string>, unsigned>
ROOP::InstructionConverter::convertInstructionSequenceToString(const byte * const instrSeqBytes, const size_t instrSeqBytesCount, AssemblySyntax asmSyntax) {
    cs_err err;
    bool handleInitialized = false;
    csh capstoneHandle;
	cs_insn *decodedInstructions = NULL;
	size_t decodedInstructionsCount;
    size_t syntaxValue;
    size_t idx;
    std::vector<std::string> decodedInstructionsAsm;
    unsigned totalDecodedBytes = 0;

	err = cs_open(CS_ARCH_X86, CS_MODE_64, &capstoneHandle);
    if (err != CS_ERR_OK) {
        printf("Capstone: cs_open() failed with error %i!\n", (int)err);
		goto cleanup;
    }
    handleInitialized = true;

    syntaxValue = (asmSyntax == AssemblySyntax::Intel) ? CS_OPT_SYNTAX_INTEL : CS_OPT_SYNTAX_ATT;
    err = cs_option(capstoneHandle, CS_OPT_SYNTAX, syntaxValue);
    if (err != CS_ERR_OK) {
        printf("Capstone: cs_option() failed with error %i!\n", (int)err);
		goto cleanup;
    }

	decodedInstructionsCount = cs_disasm(capstoneHandle, (const uint8_t *)instrSeqBytes, instrSeqBytesCount, 0x1000, 0, &decodedInstructions);
    err = cs_errno(capstoneHandle);
    if (decodedInstructionsCount == 0 && err != CS_ERR_OK) {
        printf("Capstone: cs_disasm() failed with error %i", (int)err);
        goto cleanup;
    }

    for (idx = 0; idx < decodedInstructionsCount; ++idx) {
        std::string mnemonic = std::string(decodedInstructions[idx].mnemonic);
        std::string operands = std::string(decodedInstructions[idx].op_str);

        std::string instructionAsm = mnemonic;
        if (operands.size() != 0) {
            instructionAsm += " " + operands;
        }

        decodedInstructionsAsm.push_back(instructionAsm);
        totalDecodedBytes += decodedInstructions[idx].size;
    }

cleanup:
    if (decodedInstructions != NULL) {
        cs_free(decodedInstructions, decodedInstructionsCount);
    }

    if (handleInitialized) {
	    cs_close(&capstoneHandle);
    }

// Final
    return { decodedInstructionsAsm, totalDecodedBytes };
}

std::pair<std::vector<std::string>, unsigned>
ROOP::InstructionConverter::convertInstructionSequenceToString(byteSequence instructionSequence, AssemblySyntax asmSyntax) {
    const byte *instrSeqBytes = (const byte *)instructionSequence.data();
    const size_t instrSeqBytesCount = instructionSequence.size();
    return InstructionConverter::convertInstructionSequenceToString(instrSeqBytes, instrSeqBytesCount, asmSyntax);
}

std::vector<std::string>
ROOP::InstructionConverter::normalizeInstructionAsm(std::string origInsSequenceAsm, ROOP::AssemblySyntax inputAsmSyntax) {
    const byteSequence& insSeqBytes = InstructionConverter::convertInstructionSequenceToBytes(origInsSequenceAsm, inputAsmSyntax).first;

    AssemblySyntax roopSyntax = ROOPConsts::InstructionASMSyntax;
    auto p = InstructionConverter::convertInstructionSequenceToString(insSeqBytes, roopSyntax);

    std::vector<std::string> instructions = p.first;
    assert(p.second == insSeqBytes.size());

    return instructions;
}

std::string
ROOP::InstructionConverter::concatenateInstructionsAsm(std::vector<std::string> instructionsAsm) {
    std::string ret = "";

    for (size_t i = 0; i < instructionsAsm.size(); ++i) {
        ret = (ret + instructionsAsm[i]);
        if (i != instructionsAsm.size() - 1) {
            ret += "; ";
        }
    }

    return ret;
}
